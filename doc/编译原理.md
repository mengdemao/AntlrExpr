## 编译原理

> 只涉及到了编译原理前端,可以学习ANTLR的基础知识即可

### 词法分析

#### RE2NFA

#### NFA2DFA

#### mDFA

### 语法分析

#### 自顶向下

#### LL(1)分析文法
> 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法

给出文法
```
0: S -> N V M
1: N -> s
2:   | t
3:   | g
4:   | w
5: V -> e
6:   | d
```

那么同时给出LL(1)分析表

| `N\T` | `s`  | `t`  | `g`  | `w`  | `e`  | `d`  |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: |
|  `S`  |  0   |  0   |  0   |  0   |  X   |  X   |
|  `N`  |  1   |  2   |  3   |  4   |      |      |
|  `V`  |      |      |      |      |  5   |  6   |

那么在分析`g d w`语句的时候,可以得到如下的分析

解析算法
```pascal
tokens[];
i=0;
```

那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？

##### `FIRST`集

```
令G是一个不含左递归的文法，对G的所有非终结符的每个候选a定义它的终结首符集FIRST(a)为：
FIRST(α) = { a│α ⇒∗ a…, a∈VT }
若α ⇒∗ ε ，则规定ε∈FIRST(α)。
```

构造FIRST集

+ 第一种说明：
> 对于文法G的每个文法符号X∈VT∪VN：

  - 若 X ∈ VT，则 FIRST(X) = { X }
  - 若 X ∈ NULLABLE，则把 ε 加入FIRST(X)
  - 若 X ∈ VN，且 X → a…, a ∈ VT，则把a加入到FIRST(X)中
  - 若 X ∈ VN，且 X → Y…, Y ∈ VN，则把FIRST(Y) - {ε}加到FIRST(X)中
  - 若 X →Y1Y2 … Yi , 且 Y1, Y2, … ,Yi-1 ∈ nullable，则把 FIRST(Yi) - {ε}加到FIRST(X)中
  - 若 FIRST(Ym) ∈ NULLABLE(1<=m<=i)，则ε∈FIRST(X)

+ 第二种说明：
> 对每一X∈VT∪VN，连续使用下面的规则，直至每个集合FIRST不再增大为止：

  - 若X ∈ VT，则FIRST(X)＝{X}。
  - 若X ∈ VN，且有产生式X→a…，则把a加入到FIRST(X)中；若X→ε也是一条产生式，则把 ε 也加到FIRST(X)中。
  - 若X→Y…是一个产生式且Y ∈ VN，则把FIRST(Y)中的所有非 ε- 元素都加到FIRST(X)中；若X→Y1Y2…Yi-1Yi…Yk是一个产生式，Y1，…，Yi-1都是非终结符，对于任何j，1<=j<=i-1，FIRST(Yj)都含有 ε (即Y1…Yi-1 ⇒∗ε)， 则把FIRST(Yi)中的所有非 ε-元素都加到FIRST(X)中；若所有的FIRST(Yj)均含有 ε，j＝1，2，…，k，则把 ε 加到FIRST(X)中。

##### `FOLLOW`集

##### `SELECT`集

#### 自底向上

### 语义分析

